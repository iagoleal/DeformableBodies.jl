<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Representing rotations by quaternions · DeformableBodies.jl</title><link rel="canonical" href="https://iagoleal.github.io/DeformableBodies.jl/dev/guide-quaternions/"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img class="docs-light-only" src="../assets/logo.svg" alt="DeformableBodies.jl logo"/><img class="docs-dark-only" src="../assets/logo-dark.svg" alt="DeformableBodies.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">DeformableBodies.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><a class="tocitem" href="../tutorial-cubecopter/">Tutorial</a></li><li><span class="tocitem">Guides</span><ul><li class="is-active"><a class="tocitem" href>Representing rotations by quaternions</a><ul class="internal"><li><a class="tocitem" href="#The-rotate-function"><span>The <code>rotate</code> function</span></a></li><li><a class="tocitem" href="#Representing-the-identity-rotation"><span>Representing the identity rotation</span></a></li><li><a class="tocitem" href="#Composition-of-rotations"><span>Composition of rotations</span></a></li><li><a class="tocitem" href="#Axis-angle-representation"><span>Axis-angle representation</span></a></li><li><a class="tocitem" href="#Converting-between-matrices-and-quaternions"><span>Converting between matrices and quaternions</span></a></li><li><a class="tocitem" href="#Rotating-a-PointMass"><span>Rotating a PointMass</span></a></li></ul></li></ul></li><li><span class="tocitem">Reference</span><ul><li><a class="tocitem" href="../ref-quaternions/">Quaternions</a></li><li><a class="tocitem" href="../ref-models/">DeformableBodies</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Guides</a></li><li class="is-active"><a href>Representing rotations by quaternions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Representing rotations by quaternions</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/iagoleal/DeformableBodies.jl/blob/master/docs/src/guide-quaternions.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Representing-rotations-by-quaternions"><a class="docs-heading-anchor" href="#Representing-rotations-by-quaternions">Representing rotations by quaternions</a><a id="Representing-rotations-by-quaternions-1"></a><a class="docs-heading-anchor-permalink" href="#Representing-rotations-by-quaternions" title="Permalink"></a></h1><p>The most usual ways to represent a rotation in three-dimensional space are <a href="https://en.wikipedia.org/wiki/Rotation_matrix">rotations matrices</a> or <a href="https://en.wikipedia.org/wiki/Euler_angles">Euler angles</a>. In this package, nevertheless, they are represented using unit quaternions.</p><p>Quaternions are a four-dimensional non-commutative algebra with the property that any rotation may be represented by a quaternion of norm 1. Some of their advantages consist in that we only need 4 parameters to represent a quaternion (as opposed to the 9 needed by rotation matrices) and that they do not suffer from the phenomenon of <a href="https://en.wikipedia.org/wiki/Gimbal_lock">gimbal lock</a> (as opposed to Euler angles).</p><p>If a quaternion <span>$q$</span> represents a rotation matrix <span>$R$</span>, their action on a vector is defined as</p><p class="math-container">\[R v = q v q^{-1}.\]</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>This package assumes that your coordinate system follows the right-hand rule. If, for whatever reason, you want to use a left-handed system, <span>$q$</span> and <span>$q^{-1}$</span> must be transposed on the above formula.</p></div></div><h2 id="The-rotate-function"><a class="docs-heading-anchor" href="#The-rotate-function">The <code>rotate</code> function</a><a id="The-rotate-function-1"></a><a class="docs-heading-anchor-permalink" href="#The-rotate-function" title="Permalink"></a></h2><p>All rotations on <code>DeformableBodies.jl</code> are done by the function <a href="../ref-quaternions/#DeformableBodies.Quaternions.rotate"><code>rotate</code></a>. Its signature consists of</p><pre><code class="language-julia">rotate(v::Vector, q::Quaternion, center::Vector)</code></pre><p>This function rotates the vector <code>v</code> by the rotation represented by <code>q</code> in the frame of reference centered on <code>center</code>.</p><p>If the third argument is left blank, it defaults to the origin.</p><pre><code class="language-julia-repl">julia&gt; v = [3,0,0]
3-element Array{Int64,1}:
 3
 0
 0

julia&gt; q = Quaternion(1,2,3,4)
1 + 2i + 3j + 4k

julia&gt; rotate(v, q, [0,0,0])
3-element Array{Float64,1}:
 -2.0
  2.0
  1.0

julia&gt; rotate(v, q)
3-element Array{Float64,1}:
 -2.0
  2.0
  1.0</code></pre><h2 id="Representing-the-identity-rotation"><a class="docs-heading-anchor" href="#Representing-the-identity-rotation">Representing the identity rotation</a><a id="Representing-the-identity-rotation-1"></a><a class="docs-heading-anchor-permalink" href="#Representing-the-identity-rotation" title="Permalink"></a></h2><p>The identity rotation is the matrix <span>$I$</span> satisfying <span>$I v = v$</span> for all <span>$v$</span>. This is represented by the quaternion <span>$1$</span>, which can be gotten using Julia&#39;s multiple dispatch via the expression <code>one(Quaternion)</code>.</p><pre><code class="language-julia-repl">julia&gt; q = one(Quaternion)
1 + 0i + 0j + 0k

julia&gt; rotate([1,2,3], q)
3-element Array{Float64,1}:
 1.0
 2.0
 3.0</code></pre><h2 id="Composition-of-rotations"><a class="docs-heading-anchor" href="#Composition-of-rotations">Composition of rotations</a><a id="Composition-of-rotations-1"></a><a class="docs-heading-anchor-permalink" href="#Composition-of-rotations" title="Permalink"></a></h2><p>The composition of rotations translates to the quaternion world as the product of quaternions. Thus, it is the same to rotate a vector by <span>$q_1$</span> and then by <span>$q_2$</span> and to rotate by <span>$q_2\,q_1$</span>.</p><pre><code class="language-julia-repl">julia&gt; v = [9, 0, 0]
3-element Array{Int64,1}:
 9
 0
 0

julia&gt; q1 = Quaternion(1,2,3,4)
1 + 2i + 3j + 4k

julia&gt; q2 = Quaternion(4,3,2,1)
4 + 3i + 2j + 1k

julia&gt; rotate(v, q2*q1)
3-element Array{Float64,1}:
 -1.0
 -4.0
  8.0

julia&gt; rotate(rotate(v, q1), q2)
3-element Array{Float64,1}:
 -1.0
 -4.0
  8.0</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Rotations are non-commutative. Applying <span>$q_2$</span> after <span>$q_1$</span> is the same as multiplying <span>$q_2$</span> to the <strong>left</strong> of <span>$q_1$</span>.</p></div></div><h2 id="Axis-angle-representation"><a class="docs-heading-anchor" href="#Axis-angle-representation">Axis-angle representation</a><a id="Axis-angle-representation-1"></a><a class="docs-heading-anchor-permalink" href="#Axis-angle-representation" title="Permalink"></a></h2><p>An important property of three-dimensional space it that every rotation fixes a line. Therefore, they accept an axis-angle representation. That is, a rotation <span>$R$</span> is defined by a unit vector <span>$\hat{n}$</span> and an angle <span>$\theta$</span> such that <span>$R$</span> rotates a vector counterclockwise by an amount of <span>$\theta$</span> around the line defined by <span>$\hat{n}$</span>.</p><p>To get the quaternion representing an rotation of <code>θ</code> around <code>n</code>, use the method <a href="../ref-quaternions/#DeformableBodies.Quaternions.axistoquaternion"><code>axistoquaternion</code></a>. You may pass an unormalized vector and the method will normalize it.</p><pre><code class="language-julia-repl">julia&gt; q = axistoquaternion(axis = [0,0,2], angle = π/2)
0.7071067811865476 + 0.0i + 0.0j + 0.7071067811865475k

julia&gt; rotate([1,0,0], q)
3-element Array{Float64,1}:
 2.220446049250313e-16
 1.0
 0.0</code></pre><p>In fact, this combination is so useful that the function <code>rotate</code> is overloaded to directly convert from an axis-angle pair.</p><pre><code class="language-julia-repl">julia&gt; rotate([1,0,0], axis=[0,0,1], angle=π/2)
3-element Array{Float64,1}:
 2.220446049250313e-16
 1.0
 0.0</code></pre><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>This version of <a href="../ref-quaternions/#DeformableBodies.Quaternions.rotate"><code>rotate</code></a> also accepts the optional argument <code>center</code>, which defaults to the origin.</p><pre><code class="language-">rotate([1,0,0], axis=[0,0,1], angle=π/2, center=[0,1,0])</code></pre></div></div><h2 id="Converting-between-matrices-and-quaternions"><a class="docs-heading-anchor" href="#Converting-between-matrices-and-quaternions">Converting between matrices and quaternions</a><a id="Converting-between-matrices-and-quaternions-1"></a><a class="docs-heading-anchor-permalink" href="#Converting-between-matrices-and-quaternions" title="Permalink"></a></h2><p>Sometimes a rotation may already come represented as a matrix or the transition rotations from <a href="../ref-models/#DeformableBodies.solve!"><code>solve!</code></a> may be needed in matrix form some application. To deal with these cases, the package provides two auxiliary functions <a href="../ref-quaternions/#DeformableBodies.Quaternions.matrixtoquaternion"><code>matrixtoquaternion</code></a> and <a href="../ref-quaternions/#DeformableBodies.Quaternions.quaterniontomatrix"><code>quaterniontomatrix</code></a>.</p><p>To convert a rotation matrix to a unit quaternion, do</p><pre><code class="language-julia-repl">julia&gt; R = [cos(π/4) -sin(π/4) 0;
            sin(π/4)  cos(π/4) 0;
            0         0        1]
3×3 Array{Float64,2}:
 0.707107  -0.707107  0.0
 0.707107   0.707107  0.0
 0.0        0.0       1.0

julia&gt; R * [sqrt(2), 0, 0]
3-element Array{Float64,1}:
 1.0000000000000002
 1.0
 0.0

julia&gt; q = matrixtoquaternion(R)
0.9238795325112867 + 0.0i + 0.0j + 0.3826834323650898k

julia&gt; rotate([sqrt(2), 0, 0], q)
3-element Array{Float64,1}:
 0.9999999999999999
 1.0
 0.0</code></pre><p>Some minor differences may occur due to floating-point rounding errors.</p><div class="admonition is-danger"><header class="admonition-header">Danger</header><div class="admonition-body"><p>The function <a href="../ref-quaternions/#DeformableBodies.Quaternions.matrixtoquaternion"><code>matrixtoquaternion</code></a> assumes that the input is a <em>rotation matrix</em> but, for efficency reasons, no check is done in this regard. If you do not make sure beforehand that the matrix is orthogonal, bad things may happen.</p></div></div><p>To convert a quaternion to a matrix simply do</p><pre><code class="language-julia-repl">julia&gt; q = Quaternion(1,2,3,4)
1 + 2i + 3j + 4k

julia&gt; R = quaterniontomatrix(q)
3×3 Array{Float64,2}:
 -0.666667   0.133333  0.733333
  0.666667  -0.333333  0.666667
  0.333333   0.933333  0.133333

julia&gt; rotate([3,0,0], q)
3-element Array{Float64,1}:
 -2.0
  2.0
  1.0

julia&gt; R * [3,0,0]
3-element Array{Float64,1}:
 -2.0
  2.0
  1.0</code></pre><p>The function <a href="../ref-quaternions/#DeformableBodies.Quaternions.quaterniontomatrix"><code>quaterniontomatrix</code></a> works for every quaternion, and does not require the input to be a unit quaternion.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>There is a <strong>unique</strong> rotation matrix representing a given quaternion but there are <strong>two</strong> unit quaternions representing the same matrix.</p><p>This means that <code>quaterniontomatrix ∘ matrixtoquaternion</code> equals the identity (disconsidering floating-point rouding errors) but the opposite is not in general true. For a simple example.</p><pre><code class="language-">q = Quaternion(-1.0)
(matrixtoquaternion ∘ quaterniontomatrix)(q)</code></pre><p>Nevertheless, both these quaternions produce the same rotations.</p></div></div><h2 id="Rotating-a-PointMass"><a class="docs-heading-anchor" href="#Rotating-a-PointMass">Rotating a PointMass</a><a id="Rotating-a-PointMass-1"></a><a class="docs-heading-anchor-permalink" href="#Rotating-a-PointMass" title="Permalink"></a></h2><p>All the previous functionalities only require the submodule <a href="../ref-quaternions/#DeformableBodies.Quaternions"><code>Quaternions</code></a> and work directly with vectors. Nevertheless, the models on <code>DeformableBodies.jl</code> are constructed with respect to the type <a href="../ref-models/#DeformableBodies.PointMass"><code>PointMass</code></a>. To help with that, the function rotate is overloaded to directly rotate the position of a <code>PointMass</code> without interfering with its mass.</p><pre><code class="language-julia">rotate(p::PointMass, q::Quaternion, center::Vector)
rotate(p::PointMass; axis::Vector, angle::Real, center::Vector)</code></pre><p>The usage is identical to the version for vectors including the fact that the argument <code>center</code> must be a Vector and not another PointMass.</p><p>An usual application consists in rotating a body around its center of mass.</p><pre><code class="language-julia-repl">julia&gt; body = [ PointMass(rand(), rand(3)) for i in 1:5 ]
5-element Array{PointMass{Float64},1}:
 PointMass{Float64}(0.027623475555394572, [0.622502144842952, 0.11921732534587282, 0.8843304426741481])
 PointMass{Float64}(0.08235034045511802, [0.9932241501452683, 0.334779563612172, 0.8007546565223924])
 PointMass{Float64}(0.16330720003612642, [0.386699947607279, 0.8099171674657109, 0.5908987643400341])
 PointMass{Float64}(0.8618919657812625, [0.000659859384851913, 0.7755364055477827, 0.37741989797604925])
 PointMass{Float64}(0.5806780634969708, [0.922564768890463, 0.04356399040074832, 0.18765714901619934])

julia&gt; center_of_mass(body)
3-element Array{Float64,1}:
 0.40704043526795597
 0.4993749112573767
 0.3619966261272671

julia&gt; q = Quaternion(1,2,3,4)
1 + 2i + 3j + 4k

julia&gt; rotated = [ rotate(p, q, center_of_mass(body)) for p in body ]
5-element Array{PointMass{Float64},1}:
 PointMass{Float64}(0.027623475555394572, [0.5957564162308041, 1.1179577906424625, 0.14864795800777955])
 PointMass{Float64}(0.08235034045511802, [0.31606113462014573, 1.2375345239874034, 0.46226994400353016])
 PointMass{Float64}(0.16330720003612642, [0.629867962558881, 0.5349019262226586, 0.6755761877965223])
 PointMass{Float64}(0.8618919657812625, [0.7260927511178531, 0.14668287713769346, 0.48634359841711555])
 PointMass{Float64}(0.5806780634969708, [-0.1252661931427156, 0.8787684558838791, 0.08516928092044052])

julia&gt; center_of_mass(rotated)
3-element Array{Float64,1}:
 0.40704043526795597
 0.49937491125737676
 0.361996626127267</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../tutorial-cubecopter/">« Tutorial</a><a class="docs-footer-nextpage" href="../ref-quaternions/">Quaternions »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 5 January 2021 23:01">Tuesday 5 January 2021</span>. Using Julia version 1.3.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
