var documenterSearchIndex = {"docs":
[{"location":"ref-quaternions/#Quaternions-1","page":"Quaternions","title":"Quaternions","text":"","category":"section"},{"location":"ref-quaternions/#","page":"Quaternions","title":"Quaternions","text":"Operations and methods for the algebra of quaternions and rotations. This module is independent from the remainder of DeformableBodies.jl.","category":"page"},{"location":"ref-quaternions/#Quaternion-algebra-1","page":"Quaternions","title":"Quaternion algebra","text":"","category":"section"},{"location":"ref-quaternions/#","page":"Quaternions","title":"Quaternions","text":"Quaternions\nQuaternion\ncomponents\nimagq\naxis\nnormalize","category":"page"},{"location":"ref-quaternions/#DeformableBodies.Quaternions","page":"Quaternions","title":"DeformableBodies.Quaternions","text":"Submodule of DeformableBodies.jl implementing quaternion algebra.\n\nQuaternions are a 4-dimensional normed division algebra which extend the complex numbers. They may be used as a representation of rotations on 3-dimensional space.\n\nExports\n\nQuaternion\naxis\naxistoquaternion\ncomponents\nimagq\nmatrixtoquaternion\nnormalize\nquaternion\nquaterniontomatrix\nrotate\n\n\n\n\n\n","category":"module"},{"location":"ref-quaternions/#DeformableBodies.Quaternions.Quaternion","page":"Quaternions","title":"DeformableBodies.Quaternions.Quaternion","text":"Quaternion{T<:Real} <: Number\n\nQuaternion type with components of type T.\n\nThis type overloads all the arithmetic operations as well as the methods defined for Complex numbers that still make sense for Quaternions.\n\n\n\n\n\n","category":"type"},{"location":"ref-quaternions/#DeformableBodies.Quaternions.components","page":"Quaternions","title":"DeformableBodies.Quaternions.components","text":"components(q)\n\nReturn an array with the components of a Quaternion.\n\nExample\n\njulia> components(Quaternion(1.0, 2.0, 3.0, 4.0))\n4-element Array{Float64,1}:\n 1.0\n 2.0\n 3.0\n 4.0\n\n\n\n\n\n","category":"function"},{"location":"ref-quaternions/#DeformableBodies.Quaternions.imagq","page":"Quaternions","title":"DeformableBodies.Quaternions.imagq","text":"imagq(q)\n\nReturn imaginary part of Quaternion as a Quaternion with no real part.\n\nExamples\n\njulia> a = Quaternion(1,2,3,4)\n1 + 2i + 3j + 4k\n\njulia> imagq(a)\n0 + 2i + 3j + 4k\n\n\n\n\n\n","category":"function"},{"location":"ref-quaternions/#DeformableBodies.Quaternions.axis","page":"Quaternions","title":"DeformableBodies.Quaternions.axis","text":"axis(q)\n\nReturn the unit vector on the direction of the imaginary part of a Quaternion.\n\nExamples\n\njulia> Quaternion(10,1,1,0.5)\n10.0 + 1.0i + 1.0j + 0.5k\n\njulia> axis(Quaternion(10,1,1,0.5))\n3-element Array{Float64,1}:\n 0.6666666666666666\n 0.6666666666666666\n 0.3333333333333333\n\n\n\n\n\n","category":"function"},{"location":"ref-quaternions/#DeformableBodies.Quaternions.normalize","page":"Quaternions","title":"DeformableBodies.Quaternions.normalize","text":"normalize(q)\n\nReturn a Quaternion with the same direction as q but unit norm.\n\nExamples\n\njulia> q = Quaternion([1., 1., 1., 1.])\n1.0 + 1.0i + 1.0j + 1.0k\n\njulia> a = normalize(q)\n0.5 + 0.5i + 0.5j + 0.5k\n\njulia> abs(a)\n1.0\n\n\n\n\n\n","category":"function"},{"location":"ref-quaternions/#Rotations-1","page":"Quaternions","title":"Rotations","text":"","category":"section"},{"location":"ref-quaternions/#","page":"Quaternions","title":"Quaternions","text":"rotate\naxistoquaternion\nquaterniontomatrix\nmatrixtoquaternion","category":"page"},{"location":"ref-quaternions/#DeformableBodies.Quaternions.rotate","page":"Quaternions","title":"DeformableBodies.Quaternions.rotate","text":"rotate(v::Vector, q::Quaternion, center=zeros(3))\nrotate(v::Vector; axis, angle, center=zeros(3))\n\nRotate a vector v by a quaternion q around a central point center. The quaternion may be given directly or as an axis and an angle. The point pt is optional and defaults to the origin.\n\n\n\n\n\n","category":"function"},{"location":"ref-quaternions/#DeformableBodies.Quaternions.axistoquaternion","page":"Quaternions","title":"DeformableBodies.Quaternions.axistoquaternion","text":"axistoquaternion(axis, angle)\n\nReceive an axis v and angle θ and return the Quaternion corresponding to a rotation of θ around v.\n\n\n\n\n\n","category":"function"},{"location":"ref-quaternions/#DeformableBodies.Quaternions.quaterniontomatrix","page":"Quaternions","title":"DeformableBodies.Quaternions.quaterniontomatrix","text":"quaterniontomatrix(q::Quaternion)\n\nReturn the rotation matrix associated with a Quaternion.\n\n\n\n\n\n","category":"function"},{"location":"ref-quaternions/#DeformableBodies.Quaternions.matrixtoquaternion","page":"Quaternions","title":"DeformableBodies.Quaternions.matrixtoquaternion","text":"matrixtoquaternion(R)\n\nGiven a rotation matrix R, return a unit quaternion q such that rotate(v,q) = R*v for all v.\n\nThe matrix R is assumed to be orthogonal but, for efficiency reasons, no check is made to guarantee that.\n\nSince there are, in general, two unit quaternions representing the same rotation matrix, it is not guaranteed that matrixtoquaternion ∘ quaterniontomatrix equals the identity.\n\n\n\n\n\n","category":"function"},{"location":"guide-quaternions/#Representing-rotations-by-quaternions-1","page":"Representing rotations by quaternions","title":"Representing rotations by quaternions","text":"","category":"section"},{"location":"guide-quaternions/#","page":"Representing rotations by quaternions","title":"Representing rotations by quaternions","text":"using DeformableBodies","category":"page"},{"location":"guide-quaternions/#","page":"Representing rotations by quaternions","title":"Representing rotations by quaternions","text":"The most usual ways to represent a rotation in three-dimensional space are rotations matrices or Euler angles. In this package, nevertheless, they are represented using unit quaternions.","category":"page"},{"location":"guide-quaternions/#","page":"Representing rotations by quaternions","title":"Representing rotations by quaternions","text":"Quaternions are a four-dimensional non-commutative algebra with the property that any rotation may be represented by a quaternion of norm 1. Some of their advantages consist in that we only need 4 parameters to represent a quaternion (as opposed to the 9 needed by rotation matrices) and that they do not suffer from the phenomenon of gimbal lock (as opposed to Euler angles).","category":"page"},{"location":"guide-quaternions/#","page":"Representing rotations by quaternions","title":"Representing rotations by quaternions","text":"If a quaternion q represents a rotation matrix R, their action on a vector is defined as","category":"page"},{"location":"guide-quaternions/#","page":"Representing rotations by quaternions","title":"Representing rotations by quaternions","text":"R v = q v q^-1","category":"page"},{"location":"guide-quaternions/#","page":"Representing rotations by quaternions","title":"Representing rotations by quaternions","text":"warning: Warning\nThis package assumes that your coordinate system follows the right-hand rule. If, for whatever reason, you want to use a left-handed system, q and q^-1 must be transposed on the above formula.","category":"page"},{"location":"guide-quaternions/#The-rotate-function-1","page":"Representing rotations by quaternions","title":"The rotate function","text":"","category":"section"},{"location":"guide-quaternions/#","page":"Representing rotations by quaternions","title":"Representing rotations by quaternions","text":"All rotations on DeformableBodies.jl are done by the function rotate. Its signature consists of","category":"page"},{"location":"guide-quaternions/#","page":"Representing rotations by quaternions","title":"Representing rotations by quaternions","text":"rotate(v::Vector, q::Quaternion, center::Vector)","category":"page"},{"location":"guide-quaternions/#","page":"Representing rotations by quaternions","title":"Representing rotations by quaternions","text":"This function rotates the vector v by the rotation represented by q in the frame of reference centered on center.","category":"page"},{"location":"guide-quaternions/#","page":"Representing rotations by quaternions","title":"Representing rotations by quaternions","text":"If the third argument is left blank, it defaults to the origin.","category":"page"},{"location":"guide-quaternions/#","page":"Representing rotations by quaternions","title":"Representing rotations by quaternions","text":"v = [3,0,0]\nq = Quaternion(1,2,3,4)\nrotate(v, q, [0,0,0])\nrotate(v, q)","category":"page"},{"location":"guide-quaternions/#Representing-the-identity-rotation-1","page":"Representing rotations by quaternions","title":"Representing the identity rotation","text":"","category":"section"},{"location":"guide-quaternions/#","page":"Representing rotations by quaternions","title":"Representing rotations by quaternions","text":"The identity rotation is the matrix I satisfying I v = v for all v. This is represented by the quaternion 1, which can be gotten using Julia's multiple dispatch via the expression one(Quaternion).","category":"page"},{"location":"guide-quaternions/#","page":"Representing rotations by quaternions","title":"Representing rotations by quaternions","text":"q = one(Quaternion)\nrotate([1,2,3], q)","category":"page"},{"location":"guide-quaternions/#Composition-of-rotations-1","page":"Representing rotations by quaternions","title":"Composition of rotations","text":"","category":"section"},{"location":"guide-quaternions/#","page":"Representing rotations by quaternions","title":"Representing rotations by quaternions","text":"The composition of rotations translates to the quaternion world as the product of quaternions. Thus, it is the same to rotate a vector by q_1 and then by q_2 and to rotate by q_2q_1.","category":"page"},{"location":"guide-quaternions/#","page":"Representing rotations by quaternions","title":"Representing rotations by quaternions","text":"v = [9, 0, 0]\nq1 = Quaternion(1,2,3,4)\nq2 = Quaternion(4,3,2,1)\nrotate(v, q2*q1)\nrotate(rotate(v, q1), q2)","category":"page"},{"location":"guide-quaternions/#","page":"Representing rotations by quaternions","title":"Representing rotations by quaternions","text":"note: Note\nRotations are non-commutative. Applying q_2 after q_1 is the same as multiplying q_2 to the left of q_1.","category":"page"},{"location":"guide-quaternions/#Axis-angle-representation-1","page":"Representing rotations by quaternions","title":"Axis-angle representation","text":"","category":"section"},{"location":"guide-quaternions/#","page":"Representing rotations by quaternions","title":"Representing rotations by quaternions","text":"An important property of three-dimensional space it that every rotation fixes a line. Therefore, they accept an axis-angle representation. That is, a rotation R is defined by a unit vector hatn and an angle theta such that R rotates a vector counterclockwise by an amount of theta around the line defined by hatn.","category":"page"},{"location":"guide-quaternions/#","page":"Representing rotations by quaternions","title":"Representing rotations by quaternions","text":"To get the quaternion representing an rotation of θ around n, use the method axistoquaternion. You may pass an unormalized vector and the method will normalize it.","category":"page"},{"location":"guide-quaternions/#","page":"Representing rotations by quaternions","title":"Representing rotations by quaternions","text":"q = axistoquaternion(axis = [0,0,2], angle = π/2)\nrotate([1,0,0], q)","category":"page"},{"location":"guide-quaternions/#","page":"Representing rotations by quaternions","title":"Representing rotations by quaternions","text":"In fact, this combination is so useful that the function rotate is overloaded to directly convert from an axis-angle pair.","category":"page"},{"location":"guide-quaternions/#","page":"Representing rotations by quaternions","title":"Representing rotations by quaternions","text":"rotate([1,0,0], axis=[0,0,1], angle=π/2)","category":"page"},{"location":"guide-quaternions/#","page":"Representing rotations by quaternions","title":"Representing rotations by quaternions","text":"info: Info\nThis version of rotate also accepts the optional argument center, which defaults to the origin.rotate([1,0,0], axis=[0,0,1], angle=π/2, center=[0,1,0])","category":"page"},{"location":"guide-quaternions/#Converting-between-matrices-and-quaternions-1","page":"Representing rotations by quaternions","title":"Converting between matrices and quaternions","text":"","category":"section"},{"location":"guide-quaternions/#","page":"Representing rotations by quaternions","title":"Representing rotations by quaternions","text":"Sometimes a rotation may already come represented as a matrix or the transition rotations from solve! may be needed in matrix form some application. To deal with these cases, the package provides two auxiliary functions matrixtoquaternion and quaterniontomatrix.","category":"page"},{"location":"guide-quaternions/#","page":"Representing rotations by quaternions","title":"Representing rotations by quaternions","text":"To convert a rotation matrix to a unit quaternion, do","category":"page"},{"location":"guide-quaternions/#","page":"Representing rotations by quaternions","title":"Representing rotations by quaternions","text":"R = [cos(π/4) -sin(π/4) 0;\n     sin(π/4)  cos(π/4) 0;\n     0         0        1]\nR * [sqrt(2), 0, 0]\nq = matrixtoquaternion(R)\nrotate([sqrt(2), 0, 0], q)","category":"page"},{"location":"guide-quaternions/#","page":"Representing rotations by quaternions","title":"Representing rotations by quaternions","text":"Some minor differences may occur due to floating-point rounding errors.","category":"page"},{"location":"guide-quaternions/#","page":"Representing rotations by quaternions","title":"Representing rotations by quaternions","text":"danger: Danger\nThe function matrixtoquaternion assumes that the input is a rotation matrix but, for efficency reasons, no check is done in this regard. If you do not make sure beforehand that the matrix is orthogonal, bad things may happen.","category":"page"},{"location":"guide-quaternions/#","page":"Representing rotations by quaternions","title":"Representing rotations by quaternions","text":"To convert a quaternion to a matrix simply do","category":"page"},{"location":"guide-quaternions/#","page":"Representing rotations by quaternions","title":"Representing rotations by quaternions","text":"q = Quaternion(1,2,3,4)\nR = quaterniontomatrix(q)\nrotate([3,0,0], q)\nR * [3,0,0]","category":"page"},{"location":"guide-quaternions/#","page":"Representing rotations by quaternions","title":"Representing rotations by quaternions","text":"The function quaterniontomatrix works for every quaternion, and does not require the input to be a unit quaternion.","category":"page"},{"location":"guide-quaternions/#","page":"Representing rotations by quaternions","title":"Representing rotations by quaternions","text":"note: Note\nThere is a unique rotation matrix representing a given quaternion but there are two unit quaternions representing the same matrix.This means that quaterniontomatrix ∘ matrixtoquaternion equals the identity (disconsidering floating-point rouding errors) but the opposite is not in general true. For a simple example.q = Quaternion(-1.0)\n(matrixtoquaternion ∘ quaterniontomatrix)(q)Nevertheless, both these quaternions produce the same rotations.","category":"page"},{"location":"guide-quaternions/#Rotating-a-PointMass-1","page":"Representing rotations by quaternions","title":"Rotating a PointMass","text":"","category":"section"},{"location":"guide-quaternions/#","page":"Representing rotations by quaternions","title":"Representing rotations by quaternions","text":"All the previous functionalities only require the submodule Quaternions and work directly with vectors. Nevertheless, the models on DeformableBodies.jl are constructed with respect to the type PointMass. To help with that, the function rotate is overloaded to directly rotate the position of a PointMass without interfering with its mass.","category":"page"},{"location":"guide-quaternions/#","page":"Representing rotations by quaternions","title":"Representing rotations by quaternions","text":"rotate(p::PointMass, q::Quaternion, center::Vector)\nrotate(p::PointMass; axis::Vector, angle::Real, center::Vector)","category":"page"},{"location":"guide-quaternions/#","page":"Representing rotations by quaternions","title":"Representing rotations by quaternions","text":"The usage is identical to the version for vectors including the fact that the argument center must be a Vector and not another PointMass.","category":"page"},{"location":"guide-quaternions/#","page":"Representing rotations by quaternions","title":"Representing rotations by quaternions","text":"An usual application consists in rotating a body around its center of mass.","category":"page"},{"location":"guide-quaternions/#","page":"Representing rotations by quaternions","title":"Representing rotations by quaternions","text":"body = [ PointMass(rand(), rand(3)) for i in 1:5 ]\ncenter_of_mass(body)\nq = Quaternion(1,2,3,4)\nrotated = [ rotate(p, q, center_of_mass(body)) for p in body ]\ncenter_of_mass(rotated)","category":"page"},{"location":"ref-models/#DeformableBodies-1","page":"DeformableBodies","title":"DeformableBodies","text":"","category":"section"},{"location":"ref-models/#Model-1","page":"DeformableBodies","title":"Model","text":"","category":"section"},{"location":"ref-models/#","page":"DeformableBodies","title":"DeformableBodies","text":"Model\nsolve!","category":"page"},{"location":"ref-models/#DeformableBodies.Model","page":"DeformableBodies","title":"DeformableBodies.Model","text":"Model\n\nFields\n\nbodyframe – Function representing trajectory on reference frame rotating with the body.\ntimespan  – Tuple containing starting and ending time of motion.\nq_0       – Quaternion representing initial rotation.\nL_cm      – Vector of angular momentum in relation to center of mass.\n\nOnly Initialized after solve:\n\ninertialframe – Function representing trajectory on inertial reference frame.\nrotation      – Rotations that exchange between bodyframe and inertialframe.\nmomentum      – Internal angular momentum.\n\nStore the data of a deformable body problem before and after solving.\n\n\n\n\n\n","category":"type"},{"location":"ref-models/#DeformableBodies.solve!","page":"DeformableBodies","title":"DeformableBodies.solve!","text":"solve!(m::Model; reltol=1e-8, abstol=1e-8, solver=Tsit5())\n\nReceive a Model, calculate the trajectory of the body on an inertial frame and store it in the variable m.inertialframe.\n\n\n\n\n\n","category":"function"},{"location":"ref-models/#Operators-from-mechanics-1","page":"DeformableBodies","title":"Operators from mechanics","text":"","category":"section"},{"location":"ref-models/#","page":"DeformableBodies","title":"DeformableBodies","text":"PointMass\npos\nmass\ncenter_of_mass\ninertia_tensor\nangular_momentum\ncentralize\nvelocity","category":"page"},{"location":"ref-models/#DeformableBodies.PointMass","page":"DeformableBodies","title":"DeformableBodies.PointMass","text":"PointMass(m, x)\n\nWrapper over a mass and a position on R^3.\n\nThis type overloads Quaternions.rotate to rotate only its position.\n\njulia> a = PointMass(10, [1., 0, 0])\nPointMass{Float64}(10.0, [1.0, 0.0, 0.0])\n\njulia> rotate(a; axis=[0., 0., 1.], angle=π/2)\nPointMass{Float64}(10.0, [2.220446049250313e-16, 1.0, 0.0])\n\n\n\n\n\n","category":"type"},{"location":"ref-models/#DeformableBodies.pos","page":"DeformableBodies","title":"DeformableBodies.pos","text":"pos(p::PointMass)\n\nReturn position of a PointMass.\n\n\n\n\n\n","category":"function"},{"location":"ref-models/#DeformableBodies.mass","page":"DeformableBodies","title":"DeformableBodies.mass","text":"mass(p::PointMass)\n\nReturn mass of a PointMass.\n\n\n\n\n\n","category":"function"},{"location":"ref-models/#DeformableBodies.center_of_mass","page":"DeformableBodies","title":"DeformableBodies.center_of_mass","text":"center_of_mass(xs)\n\nReceive a system of PointMasses and return their center of mass through formula\n\ncm(x) = frac1sum m_isum m_i x_i\n\n\n\n\n\n","category":"function"},{"location":"ref-models/#DeformableBodies.inertia_tensor","page":"DeformableBodies","title":"DeformableBodies.inertia_tensor","text":"inertia_tensor(xs)\n\nReceive a system of PointMasses and return their inertia tensor through formula\n\nI(x) = sum m_i Big( langle x_i x_i rangle mathrmid - x_i otimes x_i Big)\n\n\n\n\n\n","category":"function"},{"location":"ref-models/#DeformableBodies.angular_momentum","page":"DeformableBodies","title":"DeformableBodies.angular_momentum","text":"angular_momentum(xs, vs)\n\nReceive a system of PointMasses and their velocities, and return their angular momentum vector through formula\n\nL(x) = sum m_i x_i times v_i\n\n\n\n\n\n","category":"function"},{"location":"ref-models/#DeformableBodies.centralize","page":"DeformableBodies","title":"DeformableBodies.centralize","text":"centralize(xs)\n\nReceive a system of PointMasses and translate it such that the center of mass is fixed on the origin.\n\n\n\n\n\n","category":"function"},{"location":"ref-models/#DeformableBodies.velocity","page":"DeformableBodies","title":"DeformableBodies.velocity","text":"velocity(xs, t; δ=1e-6)\n\nNumerically approximate the velocity for a set xs of trajectories at time t. The variable δ denotes the step for the finite differences interval.\n\n\n\n\n\n","category":"function"},{"location":"ref-models/#Plotting-a-model-1","page":"DeformableBodies","title":"Plotting a model","text":"","category":"section"},{"location":"ref-models/#","page":"DeformableBodies","title":"DeformableBodies","text":"Modules = [DeformableBodies]\nOrder = [:type, :function]\nPages = [\"plots.jl\"]","category":"page"},{"location":"ref-models/#DeformableBodies.plotmodel-Tuple{Model,Any}","page":"DeformableBodies","title":"DeformableBodies.plotmodel","text":"plotmodel(model, SoR; kw...)\n\nReceive a Model and return a Plots.Animation from its data.\n\nArguments\n\nSoR: means \"system of reference\" and accepts one of the following symbols: :bodyframe, :inertialframe, :both.\nfps: frames per second. Default is 24.\nduration: length of animation in seconds. Default is the total timespan stored in m.\nsaveas: filename to save animation, supported extensions are gif, mp4 or mov. If left blank, file is not saved.\nbodylines: Array of points pairs. Stores the data who says which points should be linked. Default is empty.\nmarkersize_is_mass: Says if attribute markersize should be weighted by the mass of each particle. Default is true.\n\nAdditionally, any keyword argument supported by Plots.plot is accepted and will be repassed to the plot.\n\nExamples\n\njulia> plotmodel(m, :both, fps=15, saveas=\"example.gif\", color=:green,viewangle=(30,60))\n\n\n\n\n\n","category":"method"},{"location":"ref-models/#DeformableBodies.saveanimation-Tuple{Any,String}","page":"DeformableBodies","title":"DeformableBodies.saveanimation","text":"saveanimation(anime, saveas; fps=30)\n\nReceive an Plots.Animation and save it as a file.\n\nSupported formats are 'gif', 'mp4' and 'mov'. The extension is automatically detected from saveas and, in case of ambiguity, defaults to '.gif'.\n\n\n\n\n\n","category":"method"},{"location":"tutorial-cubecopter/#Tutorial:-The-Cubecopter-1","page":"Tutorial","title":"Tutorial: The Cubecopter","text":"","category":"section"},{"location":"tutorial-cubecopter/#","page":"Tutorial","title":"Tutorial","text":"In this page we model the movement of a simple deformable body on a reference frame moving with it and then solve the problem to find its trajectory from the point of view of an inertial frame.","category":"page"},{"location":"tutorial-cubecopter/#","page":"Tutorial","title":"Tutorial","text":"using DeformableBodies","category":"page"},{"location":"tutorial-cubecopter/#","page":"Tutorial","title":"Tutorial","text":"The example body will be a cube attached to rotating helix, from now on comradely referred to as the cubecopter. Each particle is represented by a PointMass, and the full body is an array of point masses.","category":"page"},{"location":"tutorial-cubecopter/#","page":"Tutorial","title":"Tutorial","text":"r_0 = [\n      PointMass(1., [ 1.,  1.,  0.])\n    , PointMass(1., [ 1., -1.,  0.])\n    , PointMass(1., [-1.,  1.,  0.])\n    , PointMass(1., [-1., -1.,  0.])\n    , PointMass(1., [ 1.,  1., -1.])\n    , PointMass(1., [ 1., -1., -1.])\n    , PointMass(1., [-1.,  1., -1.])\n    , PointMass(1., [-1., -1., -1.])\n    , PointMass(.5, [-1.,  0.,  .5])\n    , PointMass(.5, [ 1.,  0.,  .5])\n    ]\nnothing; #hide","category":"page"},{"location":"tutorial-cubecopter/#","page":"Tutorial","title":"Tutorial","text":"For visualization purposes, the plot function from Plots.jl is overloaded to work with arrays of point masses.","category":"page"},{"location":"tutorial-cubecopter/#","page":"Tutorial","title":"Tutorial","text":"using Plots: plot\nusing Plots: gr; gr(size=(400,400), markercolor=:purple); #hide\nplot(r_0)","category":"page"},{"location":"tutorial-cubecopter/#","page":"Tutorial","title":"Tutorial","text":"It may be hard to visualize a lot of points scattered on a 3D graph. Therefore, the plot function is also overloaded to accept a parameter bodylines connecting some particles. It does not interferes on the dynamics and serves only for aiding visualization.","category":"page"},{"location":"tutorial-cubecopter/#","page":"Tutorial","title":"Tutorial","text":"Below is a nasty hack for calculating the cubecopter's edges. You do not have to understand it. The important part is that the variable edges is an array of indexes representing which points should be connected.","category":"page"},{"location":"tutorial-cubecopter/#","page":"Tutorial","title":"Tutorial","text":"edges = Tuple[]\nfor i = 1:length(r_0), j = i:length(r_0)\n    if count(a -> first(a) == last(a), zip(pos(r_0[i]),pos(r_0[j]))) == 2\n        push!(edges, (i,j))\n    end\nend","category":"page"},{"location":"tutorial-cubecopter/#","page":"Tutorial","title":"Tutorial","text":"plot(r_0, bodylines=edges)","category":"page"},{"location":"tutorial-cubecopter/#","page":"Tutorial","title":"Tutorial","text":"Much better, right?","category":"page"},{"location":"tutorial-cubecopter/#","page":"Tutorial","title":"Tutorial","text":"Now, the array r_0 represents a stationary body. What we want is a trajectory over time, represented by an array of functions. Our chosen trajectory will be a stationary cube with an helix rotating counter-clockwise over it.","category":"page"},{"location":"tutorial-cubecopter/#","page":"Tutorial","title":"Tutorial","text":"For the cube part, we represent these as constant functions.","category":"page"},{"location":"tutorial-cubecopter/#","page":"Tutorial","title":"Tutorial","text":"trajectory = Function[]\nfor x in r_0[1:end-2]\n    push!(trajectory, let x=x; t -> x;end)\nend\nnothing; #hide","category":"page"},{"location":"tutorial-cubecopter/#","page":"Tutorial","title":"Tutorial","text":"While the helix movement is done using the function rotate over a fixed axis with an angle varying over time.","category":"page"},{"location":"tutorial-cubecopter/#","page":"Tutorial","title":"Tutorial","text":"const ω = 2*π/5.0            # Angular velocity\nconst z_axis  = [0., 0., 1.] # Axis of rotation is orthogonal to helix\n\nfor x in r_0[end-1:end]\n    push!(trajectory, let x=x; t -> rotate(x, axis=z_axis, angle=ω*t); end)\nend\nnothing; #hide","category":"page"},{"location":"tutorial-cubecopter/#","page":"Tutorial","title":"Tutorial","text":"With this, we complete the code for the trajectory on the body frame. Let's animate it so we can see how the trajectory behaves.","category":"page"},{"location":"tutorial-cubecopter/#","page":"Tutorial","title":"Tutorial","text":"using Plots: Animation, frame, gif\nanime = Animation()\nfor t in 0.:0.1:7.\n    frame(anime, plot([ x(t) for x in trajectory], bodylines=edges))\nend\ngif(anime)","category":"page"},{"location":"tutorial-cubecopter/#","page":"Tutorial","title":"Tutorial","text":"It is now time to define the problem's model and find the trajectory on the inertial frame. First, we need to define some initial data.","category":"page"},{"location":"tutorial-cubecopter/#","page":"Tutorial","title":"Tutorial","text":"tstart  = 0.                # Starting time\ntend    = 5.                # Ending time\nRstart  = one(Quaternion)   # Initial rotation\nL_cm    = zeros(3)          # Angular momentum as viewed from center of mass\nnothing; #hide","category":"page"},{"location":"tutorial-cubecopter/#","page":"Tutorial","title":"Tutorial","text":"The variables tstart and tend define respectively the starting and ending time for the dynamics. The other two variables are the initial data necessary to solve the differential equation. The term one(Quaternion) is our way to represent the identity rotation, meaning that at the starting time, the inertial frame coincides with the body frame. The variable L_cm is set to zero, meaning that the total angular momentum is zero from the point of view of the center of mass.","category":"page"},{"location":"tutorial-cubecopter/#","page":"Tutorial","title":"Tutorial","text":"With this information, we are ready to define our Model.","category":"page"},{"location":"tutorial-cubecopter/#","page":"Tutorial","title":"Tutorial","text":"model = Model( trajectory\n             , timespan = (tstart, tend)\n             , q_0  = Rstart\n             , L_cm = L_cm\n             )\nnothing; #hide","category":"page"},{"location":"tutorial-cubecopter/#","page":"Tutorial","title":"Tutorial","text":"Now that everything is setted up, finding the inertial frame trajectory is as simple as writing","category":"page"},{"location":"tutorial-cubecopter/#","page":"Tutorial","title":"Tutorial","text":"solve!(model)\nnothing; #hide","category":"page"},{"location":"tutorial-cubecopter/#","page":"Tutorial","title":"Tutorial","text":"To visualize the final result, we can use the function plotmodel to plot and save an animation of the dynamics of both frames side by side.","category":"page"},{"location":"tutorial-cubecopter/#","page":"Tutorial","title":"Tutorial","text":"# Ugly hack to make sure that no output comes from Plots.gif\ngr(size=(800,400))\nplotmodel( model\n         , :both\n         , saveas=\"cubecopter.gif\"\n         , bodylines=edges          # Only for visualization\n         , duration=5.0             # Duration in seconds\n         )","category":"page"},{"location":"tutorial-cubecopter/#","page":"Tutorial","title":"Tutorial","text":"plotmodel( model\n         , :both\n         , saveas=\"cubecopter.gif\"\n         , bodylines=edges          # Only for visualization\n         , duration=5.0             # Duration in seconds\n         )","category":"page"},{"location":"tutorial-cubecopter/#","page":"Tutorial","title":"Tutorial","text":"(Image: See how it spins!)","category":"page"},{"location":"tutorial-cubecopter/#","page":"Tutorial","title":"Tutorial","text":"In the inertial frame, the cube rotates in the opposite direction to the helix guaranteeing that the total angular momentum is conserved.","category":"page"},{"location":"#Deformable-Bodies-Dynamics-1","page":"Introduction","title":"Deformable Bodies Dynamics","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"DeformableBodies.jl is a Julia package dedicated to the study and solution of a special class of problems from classical mechanics: deformable bodies.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"The data needed for solving a deformable body problem consists of the body trajectory with respect to an arbitrary reference frame. Given this, we can reconstruct the body's trajectory from the point of view of an inertial frame as a sequence of rotations from one frame to the other. In order to avoid gimbal lock, all the rotations in this package are represented using unit quaternions.","category":"page"},{"location":"#Example-1","page":"Introduction","title":"Example","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"The figure below represents the movement that a falling cat[disclaimer] does when righting itself midair both from the perspective of a frame rotating together with the cat and from an inertial frame.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"(Image: Falling cat dynamics)","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"[disclaimer]: No real cats were harmed during the development of this program.","category":"page"},{"location":"#Installation-1","page":"Introduction","title":"Installation","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"This package can be installed using the Julia Package Manager. Simply open the REPL and run","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"import Pkg\nPkg.add(\"https://github.com/iagoleal/DeformableBodies.jl.git\")","category":"page"},{"location":"#Science-behind-the-camera-1","page":"Introduction","title":"Science behind the camera","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"This package is based on a scientific initiation that I did with Prof. Alejandro Cabrera while an undergraduate at UFRJ. Everything in here is based on Alejandro's paper:","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Cabrera, Alejandro. “A Generalized Montgomery Phase Formula for Rotating Self-Deforming Bodies.” Journal of Geometry and Physics 57.5 (2007): 1405–1420. Crossref. Web.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Furthermore, this package strongly builds upon the fantastic work done by DifferentialEquations.jl and Plots.jl. Make sure to also check these projects.","category":"page"}]
}
