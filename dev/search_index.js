var documenterSearchIndex = {"docs":
[{"location":"ref-quaternions.html#Quaternions-1","page":"Quaternions","title":"Quaternions","text":"","category":"section"},{"location":"ref-quaternions.html#","page":"Quaternions","title":"Quaternions","text":"Operations and methods for the algebra of quaternions and rotations. This module is independent from the remainder of DeformableBodies.jl.","category":"page"},{"location":"ref-quaternions.html#Quaternion-algebra-1","page":"Quaternions","title":"Quaternion algebra","text":"","category":"section"},{"location":"ref-quaternions.html#","page":"Quaternions","title":"Quaternions","text":"Quaternions\nQuaternion\ncomponents\nimagq\naxis\nnormalize","category":"page"},{"location":"ref-quaternions.html#DeformableBodies.Quaternions","page":"Quaternions","title":"DeformableBodies.Quaternions","text":"Submodule of DeformableBodies.jl implementing quaternion algebra.\n\nQuaternions are a 4-dimensional normed division algebra which extend the complex numbers. They may be used as a representation of rotations on 3-dimensional space.\n\nExports\n\nQuaternion\naxis\naxistoquaternion\ncomponents\nimagq\nmatrixtoquaternion\nnormalize\nquaterniontomatrix\nrotate\n\n\n\n\n\n","category":"module"},{"location":"ref-quaternions.html#DeformableBodies.Quaternions.Quaternion","page":"Quaternions","title":"DeformableBodies.Quaternions.Quaternion","text":"Quaternion{T<:Real} <: Number\n\nQuaternion type with components of type T.\n\nThis type overloads all the arithmetic operations as well as the methods defined for Complex numbers that still make sense for Quaternions.\n\n\n\n\n\n","category":"type"},{"location":"ref-quaternions.html#DeformableBodies.Quaternions.components","page":"Quaternions","title":"DeformableBodies.Quaternions.components","text":"components(q)\n\nReturn an array with the components of a Quaternion.\n\nExample\n\njulia> components(Quaternion(1.0, 2.0, 3.0, 4.0))\n4-element Array{Float64,1}:\n 1.0\n 2.0\n 3.0\n 4.0\n\n\n\n\n\n","category":"function"},{"location":"ref-quaternions.html#DeformableBodies.Quaternions.imagq","page":"Quaternions","title":"DeformableBodies.Quaternions.imagq","text":"imagq(q)\n\nReturn imaginary part of Quaternion as a Quaternion with no real part.\n\nExamples\n\njulia> a = Quaternion(1,2,3,4)\n1 + 2i + 3j + 4k\n\njulia> imagq(a)\n0 + 2i + 3j + 4k\n\n\n\n\n\n","category":"function"},{"location":"ref-quaternions.html#DeformableBodies.Quaternions.axis","page":"Quaternions","title":"DeformableBodies.Quaternions.axis","text":"axis(q)\n\nReturn the unit vector on the direction of the imaginary part of a Quaternion.\n\nExamples\n\njulia> Quaternion(10,1,1,0.5)\n10.0 + 1.0i + 1.0j + 0.5k\n\njulia> axis(Quaternion(10,1,1,0.5))\n3-element Array{Float64,1}:\n 0.6666666666666666\n 0.6666666666666666\n 0.3333333333333333\n\n\n\n\n\n","category":"function"},{"location":"ref-quaternions.html#DeformableBodies.Quaternions.normalize","page":"Quaternions","title":"DeformableBodies.Quaternions.normalize","text":"normalize(q)\n\nReturn a Quaternion with the same direction as q but unit norm.\n\nExamples\n\njulia> q = Quaternion([1., 1., 1., 1.])\n1.0 + 1.0i + 1.0j + 1.0k\n\njulia> a = normalize(q)\n0.5 + 0.5i + 0.5j + 0.5k\n\njulia> abs(a)\n1.0\n\n\n\n\n\n","category":"function"},{"location":"ref-quaternions.html#Rotations-1","page":"Quaternions","title":"Rotations","text":"","category":"section"},{"location":"ref-quaternions.html#","page":"Quaternions","title":"Quaternions","text":"rotate\naxistoquaternion\nquaterniontomatrix\nmatrixtoquaternion","category":"page"},{"location":"ref-quaternions.html#DeformableBodies.Quaternions.rotate","page":"Quaternions","title":"DeformableBodies.Quaternions.rotate","text":"rotate(v::Vector, q::Quaternion)\nrotate(v::Vector; axis, angle)\n\nRotate a vector v by a quaternion q. The quaternion may be given directly or as an axis and an angle.\n\n\n\n\n\n","category":"function"},{"location":"ref-quaternions.html#DeformableBodies.Quaternions.axistoquaternion","page":"Quaternions","title":"DeformableBodies.Quaternions.axistoquaternion","text":"axistoquaternion(axis, angle)\n\nReceive an axis v and angle θ and return the Quaternion corresponding to a rotation of θ around v.\n\n\n\n\n\n","category":"function"},{"location":"ref-quaternions.html#DeformableBodies.Quaternions.quaterniontomatrix","page":"Quaternions","title":"DeformableBodies.Quaternions.quaterniontomatrix","text":"quaterniontomatrix(q::Quaternion)\n\nReturn the rotation matrix associated with a Quaternion.\n\n\n\n\n\n","category":"function"},{"location":"ref-quaternions.html#DeformableBodies.Quaternions.matrixtoquaternion","page":"Quaternions","title":"DeformableBodies.Quaternions.matrixtoquaternion","text":"matrixtoquaternion(R)\n\nGiven a rotation matrix R, return a quaternion q such that rotate(v,q) = R*v for all v.\n\nThe matrix R is assumed to be orthogonal but, for efficiency reasons, no check is made to guarantee that.\n\nSince there are, in general, two quaternions representing the same rotation matrix, it is not guaranteed that matrixtoquaternion ∘ quaterniontomatrix equals the identity.\n\n\n\n\n\n","category":"function"},{"location":"ref-models.html#DeformableBodies-1","page":"DeformableBodies","title":"DeformableBodies","text":"","category":"section"},{"location":"ref-models.html#Model-1","page":"DeformableBodies","title":"Model","text":"","category":"section"},{"location":"ref-models.html#","page":"DeformableBodies","title":"DeformableBodies","text":"Model\nsolve!","category":"page"},{"location":"ref-models.html#DeformableBodies.Model","page":"DeformableBodies","title":"DeformableBodies.Model","text":"Model\n\nStore the data of a deformable body problem before and after solving.\n\n\n\n\n\n","category":"type"},{"location":"ref-models.html#DeformableBodies.solve!","page":"DeformableBodies","title":"DeformableBodies.solve!","text":"solve!(m::Model; reltol=1e-8, abstol=1e-8, solver=Tsit5())\n\nReceive a Model, calculate the trajectory of the body on an inertial frame and store it in the variable m.inertialframe.\n\n\n\n\n\n","category":"function"},{"location":"ref-models.html#Operators-from-mechanics-1","page":"DeformableBodies","title":"Operators from mechanics","text":"","category":"section"},{"location":"ref-models.html#","page":"DeformableBodies","title":"DeformableBodies","text":"PointMass\npos\nmass\ncenter_of_mass\ninertia_tensor\nangular_momentum\ncentralize\nvelocity","category":"page"},{"location":"ref-models.html#DeformableBodies.PointMass","page":"DeformableBodies","title":"DeformableBodies.PointMass","text":"PointMass(m, x)\n\nWrapper over a mass and a position on R^3.\n\nThis type overloads Quaternions.rotate to rotate only its position.\n\njulia> a = PointMass(10, [1., 0, 0])\nPointMass{Float64}(10.0, [1.0, 0.0, 0.0])\n\njulia> rotate(a; axis=[0., 0., 1.], angle=π/2)\nPointMass{Float64}(10.0, [2.220446049250313e-16, 1.0, 0.0])\n\n\n\n\n\n","category":"type"},{"location":"ref-models.html#DeformableBodies.pos","page":"DeformableBodies","title":"DeformableBodies.pos","text":"pos(p::PointMass)\n\nReturn position of a PointMass.\n\n\n\n\n\n","category":"function"},{"location":"ref-models.html#DeformableBodies.mass","page":"DeformableBodies","title":"DeformableBodies.mass","text":"mass(p::PointMass)\n\nReturn mass of a PointMass.\n\n\n\n\n\n","category":"function"},{"location":"ref-models.html#DeformableBodies.center_of_mass","page":"DeformableBodies","title":"DeformableBodies.center_of_mass","text":"center_of_mass(xs)\n\nReceive a system of PointMasses and return their center of mass through formula\n\ncm(x) = frac1sum m_isum m_i x_i\n\n\n\n\n\n","category":"function"},{"location":"ref-models.html#DeformableBodies.inertia_tensor","page":"DeformableBodies","title":"DeformableBodies.inertia_tensor","text":"inertia_tensor(xs)\n\nReceive a system of PointMasses and return their inertia tensor through formula\n\nI(x) = sum m_i langle x_i x_i rangle mathrmid - x_i otimes x_i\n\n\n\n\n\n","category":"function"},{"location":"ref-models.html#DeformableBodies.angular_momentum","page":"DeformableBodies","title":"DeformableBodies.angular_momentum","text":"angular_momentum(xs, vs)\n\nReceive a system of PointMasses and their velocities, and return their angular momentum vector through formula\n\nL(x) = sum m_i x_i times v_i\n\n\n\n\n\n","category":"function"},{"location":"ref-models.html#DeformableBodies.centralize","page":"DeformableBodies","title":"DeformableBodies.centralize","text":"centralize(xs)\n\nReceive a system of PointMasses and translate it such that the center of mass is fixed on the origin.\n\n\n\n\n\n","category":"function"},{"location":"ref-models.html#DeformableBodies.velocity","page":"DeformableBodies","title":"DeformableBodies.velocity","text":"velocity(xs, t; δ=1e-6)\n\nNumerically approximate the velocity for a set xs of trajectories at time t. The variable δ denotes the step for the finite differences interval.\n\n\n\n\n\n","category":"function"},{"location":"ref-models.html#Plotting-a-model-1","page":"DeformableBodies","title":"Plotting a model","text":"","category":"section"},{"location":"ref-models.html#","page":"DeformableBodies","title":"DeformableBodies","text":"Modules = [DeformableBodies]\nOrder = [:type, :function]\nPages = [\"plots.jl\"]","category":"page"},{"location":"ref-models.html#DeformableBodies.plotmodel-Tuple{Model,Any}","page":"DeformableBodies","title":"DeformableBodies.plotmodel","text":"plotmodel(model, SoR; kw...)\n\nReceive a Model and return a Plots.Animation from its data.\n\nArguments\n\nSoR: means \"system of reference\" and accepts one of the following symbols: :bodyframe, :inertialframe, :both.\nfps: frames per second. Default is 24.\nduration: length of animation in seconds. Default is model.t_max.\nsaveas: filename to save animation, supported extensions are gif, mp4 or mov. If left blank, file is not saved.\nbodylines: Array of points pairs. Stores the data who says which points should be linked. Default is empty.\nmarkersize_is_mass: Says if attribute markersize should be weighted by the mass of each particle. Default is true.\n\nAdditionally, any keyword argument supported by Plots.plot is accepted and will be repassed to the plot.\n\nExamples\n\njulia> plotmodel(m, :both, fps=15, saveas=\"example.gif\", color=:green,viewangle=(30,60))\n\n\n\n\n\n","category":"method"},{"location":"ref-models.html#DeformableBodies.saveanimation-Tuple{Any,String}","page":"DeformableBodies","title":"DeformableBodies.saveanimation","text":"saveanimation(anime, saveas; fps=30)\n\nReceive an Plots.Animation and save it as a file.\n\nSupported formats are 'gif', 'mp4' and 'mov'. The extension is automatically detected from saveas and, in case of ambiguity, defaults to '.gif'.\n\n\n\n\n\n","category":"method"},{"location":"tutorial-cubecopter.html#Tutorial:-The-Cubecopter-1","page":"Tutorial","title":"Tutorial: The Cubecopter","text":"","category":"section"},{"location":"tutorial-cubecopter.html#","page":"Tutorial","title":"Tutorial","text":"In this page we model the movement of a simple deformable body on a reference frame moving with it and then solve the problem to find its trajectory from the point of view of an inertial frame.","category":"page"},{"location":"tutorial-cubecopter.html#","page":"Tutorial","title":"Tutorial","text":"using DeformableBodies","category":"page"},{"location":"tutorial-cubecopter.html#","page":"Tutorial","title":"Tutorial","text":"The example body will be a cube attached to rotating helix, from now on comradely referred to as the cubecopter. Each particle is represented by a PointMass, and the full body is an array of point masses.","category":"page"},{"location":"tutorial-cubecopter.html#","page":"Tutorial","title":"Tutorial","text":"r_0 = [\n      PointMass(1., [ 1.,  1.,  0.])\n    , PointMass(1., [ 1., -1.,  0.])\n    , PointMass(1., [-1.,  1.,  0.])\n    , PointMass(1., [-1., -1.,  0.])\n    , PointMass(1., [ 1.,  1., -1.])\n    , PointMass(1., [ 1., -1., -1.])\n    , PointMass(1., [-1.,  1., -1.])\n    , PointMass(1., [-1., -1., -1.])\n    , PointMass(.5, [-1.,  0.,  .5])\n    , PointMass(.5, [ 1.,  0.,  .5])\n    ]\nnothing; #hide","category":"page"},{"location":"tutorial-cubecopter.html#","page":"Tutorial","title":"Tutorial","text":"For visualization purposes, the plot function from Plots.jl is overloaded to work with arrays of point masses.","category":"page"},{"location":"tutorial-cubecopter.html#","page":"Tutorial","title":"Tutorial","text":"using Plots: plot\nusing Plots: gr; gr(size=(400,400), markercolor=:purple); #hide\nplot(r_0)","category":"page"},{"location":"tutorial-cubecopter.html#","page":"Tutorial","title":"Tutorial","text":"It may be hard to visualize a lot of points scattered on a 3D graph. Therefore, the plot function is also overloaded to accept a parameter bodylines connecting some particles. It does not interferes on the dynamics and serves only for aiding visualization.","category":"page"},{"location":"tutorial-cubecopter.html#","page":"Tutorial","title":"Tutorial","text":"Below is a nasty hack for calculating the cubecopter's edges. You do not have to understand it. The important part is that the variable edges is an array of indexes representing which points should be connected.","category":"page"},{"location":"tutorial-cubecopter.html#","page":"Tutorial","title":"Tutorial","text":"edges = Tuple[]\nfor i = 1:length(r_0), j = i:length(r_0)\n    if count(a -> first(a) == last(a), zip(pos(r_0[i]),pos(r_0[j]))) == 2\n        push!(edges, (i,j))\n    end\nend","category":"page"},{"location":"tutorial-cubecopter.html#","page":"Tutorial","title":"Tutorial","text":"plot(r_0, bodylines=edges)","category":"page"},{"location":"tutorial-cubecopter.html#","page":"Tutorial","title":"Tutorial","text":"Much better, right?","category":"page"},{"location":"tutorial-cubecopter.html#","page":"Tutorial","title":"Tutorial","text":"Now, the array r_0 represents a stationary body. What we want is a trajectory over time, represented by an array of functions. Our chosen trajectory will be a stationary cube with an helix rotating counter-clockwise over it.","category":"page"},{"location":"tutorial-cubecopter.html#","page":"Tutorial","title":"Tutorial","text":"For the cube part, we represent these as constant functions.","category":"page"},{"location":"tutorial-cubecopter.html#","page":"Tutorial","title":"Tutorial","text":"# Define an array of trajectories\ntrajectories = Function[]\nfor x in r_0[1:end-2]\n    push!(trajectories, let x=x; t -> x;end)\nend\nnothing; #hide","category":"page"},{"location":"tutorial-cubecopter.html#","page":"Tutorial","title":"Tutorial","text":"While the helix movement is done using the function rotate over a fixed axis with an angle varying over time.","category":"page"},{"location":"tutorial-cubecopter.html#","page":"Tutorial","title":"Tutorial","text":"const ω = 2*π/5.0            # Angular velocity\nconst z_axis  = [0., 0., 1.] # Axis of rotation is orthogonal to helix\n\nfor x in r_0[end-1:end]\n    push!(trajectories, let x=x; t -> rotate(x, axis=z_axis, angle=ω*t); end)\nend\nnothing; #hide","category":"page"},{"location":"tutorial-cubecopter.html#","page":"Tutorial","title":"Tutorial","text":"With this, we complete the code for the trajectory on the body frame. Let's animate it so we can see how the trajectory behaves.","category":"page"},{"location":"tutorial-cubecopter.html#","page":"Tutorial","title":"Tutorial","text":"using Plots: @gif, Animation, frame, gif\n@gif for t in 0.:0.1:7.\n    plot([ x(t) for x in trajectories], bodylines=edges)\nend","category":"page"},{"location":"tutorial-cubecopter.html#","page":"Tutorial","title":"Tutorial","text":"It is now time to define the problem's model and find the trajectory on the inertial frame. First, we need to define some initial data.","category":"page"},{"location":"tutorial-cubecopter.html#","page":"Tutorial","title":"Tutorial","text":"tstart = 0.\ntend   = 5.\ninitial_rotation = one(Quaternion)\ninitial_angular_momentum = zeros(3)\nnothing; #hide","category":"page"},{"location":"tutorial-cubecopter.html#","page":"Tutorial","title":"Tutorial","text":"The variables tstart and tend define respectively the starting and ending time for the dynamics. The other two variables are the initial data necessary to solve the differential equation. The term one(Quaternion) is our way to represent the identity rotation, meaning that at the starting time, the inertial frame coincides with the body frame. The variable initial_angular_momentum is set to zero, meaning that at the beginning of the trajectory, the body has zero angular momentum from the point of view of the inertial frame.","category":"page"},{"location":"tutorial-cubecopter.html#","page":"Tutorial","title":"Tutorial","text":"With this information, we are ready to define our Model.","category":"page"},{"location":"tutorial-cubecopter.html#","page":"Tutorial","title":"Tutorial","text":"model = Model( trajectories\n             , tstart\n             , tend\n             , initial_rotation\n             , initial_angular_momentum\n             )\nnothing; #hide","category":"page"},{"location":"tutorial-cubecopter.html#","page":"Tutorial","title":"Tutorial","text":"Now that everything is setted up, finding the inertial frame trajectory is as simple as writing","category":"page"},{"location":"tutorial-cubecopter.html#","page":"Tutorial","title":"Tutorial","text":"solve!(model)\nnothing; #hide","category":"page"},{"location":"tutorial-cubecopter.html#","page":"Tutorial","title":"Tutorial","text":"To visualize the final result, we can use the function plotmodel to plot and save an animation of the dynamics of both frames side by side.","category":"page"},{"location":"tutorial-cubecopter.html#","page":"Tutorial","title":"Tutorial","text":"# Ugly hack to make sure that no output comes from Plots.gif\ngr(size=(800,400))\nplotmodel( model\n         , :both\n         , saveas=\"cubecopter.gif\"\n         , bodylines=edges          # Only for visualization\n         , duration=5.0             # Duration in seconds\n         )","category":"page"},{"location":"tutorial-cubecopter.html#","page":"Tutorial","title":"Tutorial","text":"plotmodel( model\n         , :both\n         , saveas=\"cubecopter.gif\"\n         , bodylines=edges          # Only for visualization\n         , duration=5.0             # Duration in seconds\n         )","category":"page"},{"location":"tutorial-cubecopter.html#","page":"Tutorial","title":"Tutorial","text":"(Image: See how it spins!)","category":"page"},{"location":"tutorial-cubecopter.html#","page":"Tutorial","title":"Tutorial","text":"In the inertial frame, the cube rotates in the opposite direction to the helix guaranteeing that the total angular momentum is conserved.","category":"page"},{"location":"index.html#Deformable-Bodies-Dynamics-1","page":"Introduction","title":"Deformable Bodies Dynamics","text":"","category":"section"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"DeformableBodies.jl is a Julia package dedicated to the study and solution of a special class of problems from classical mechanics: deformable bodies.","category":"page"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"The data needed for solving a deformable body problem consists of the body trajectory with respect to an arbitrary reference frame. Given this, we can reconstruct the body's trajectory from the point of view of an inertial frame as a sequence of rotations from one frame to the other. In order to avoid gimbal lock, all the rotations in this package are represented using unit quaternions.","category":"page"},{"location":"index.html#Example-1","page":"Introduction","title":"Example","text":"","category":"section"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"The figure below represents the movement that a falling cat does when righting itself midair both from the perspective of a frame rotating together with the cat and from an inertial frame.","category":"page"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"(Image: Falling cat dynamics)","category":"page"},{"location":"index.html#Installation-1","page":"Introduction","title":"Installation","text":"","category":"section"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"This package can be installed using the Julia Package Manager. Simply open the REPL and run","category":"page"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"import Pkg\nPkg.add(\"https://github.com/iagoleal/DeformableBodies.jl.git\")","category":"page"},{"location":"index.html#Science-behind-the-camera-1","page":"Introduction","title":"Science behind the camera","text":"","category":"section"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"This package is based on a scientific initiation that I did with Prof. Alejandro Cabrera while a undergraduate at UFRJ. Everything in here is based on Alejandro's paper","category":"page"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"Cabrera, Alejandro. “Base-Controlled Mechanical Systems and Geometric Phases.” Journal of Geometry and Physics 58.3 (2008): 334–367. Crossref. Web.","category":"page"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"Furthermore, this package strongly builds upon the fantastic work done by DifferentialEquations.jl and Plots.jl. Make sure to also check these projects.","category":"page"}]
}
